http://bit.ly/fr-springboot

※ 개발환경
- Java 11
- Gradle 4.8 ~ Gradle 4.10.2
----------------------------------------------------------------------------------------------------------------------------------------------

MyBatis, iBatis는 ORM이 아닙니다. SQL Mapper입니다. 가끔 ORM에 대해 MyBatis, iBatis를 얘기하게 되는데 이 둘은 ORM이 아닙니다. ORM은 객체를 매핑하는 것이고, SQL Mapper는 쿼리를 매핑합니다.

----------------------------------------------------------------------------------------------------------------------------------------------

JPA 소개
- 현대의 웹 애플리케이션에서 관계형 데이터베이스는 빠질 수 없는 요소입니다. Oracle, MySQL, MSSQL등을 쓰지 않는 웹 애플리케이션은  거의 없습니다. 그러다 보니 ★객체를 관계형 데이터베이스에서 관리★하는 것이 무엇보다 중요합니다. 관계형 데이터베이스가 계속해서 웹 서비스의 중심이 되면서 모든 코드는 SQL 중심이 되어갑니다. 현업 프로젝트 대부분이 애플리케이션 코드보다 SQL로 가득하게 된 것입니다.
 이는 관계형 데이터베이스가 SQL만 인식할 수 있기 때문인데, SQL로만 가능하니 각 테이블마다 기본적인 CRUD SQL을 매번 생성해야 합니다. 예를 들어 User 객체를 테이블로 관리한다면 다음의 코드를 피할 수 없습니다.
				| insert into user (id, name, ...) values (...);  |
				| select * from user where ...; 		  |
				| update user set ... where ...;     	  |
				| delete from user where ...;		  |
관계형 데이터베이스를 사용해야만 하는 상황에서 SQL은 피할 수 없습니다. 이런 단순 반복 작업의 문제 외에도 문제가 더 있습니다.
패러다임 불일치 문제 입니다. 관계형 데이터베이스는 ★어떻게 데이터를 저장★할지에 초점이 맞춰진 기술입니다.
반대로 객체지향 프로그래밍 언어는 메시지를 기반으로 ★기능과 속성을 한 곳에서 관리★하는 기술입니다.
관계형 데이터베이스와 객체지향 프로그래밍 언어의 패러다임이 서로 다른데, 객체를 데이터베이스에 저장하려고 하니 여러 문제가 발생합니다. 이를 ★패러다임 불일치★ 라고 합니다. 객체지향 프로그래밍에서 부모가 되는 객체를 가져오려면 어떻게 해야할까요?
				| User user = findUser();	       |
				| Group group = user.getGroup();  |
누구나 명확하게 ★User와 Group은 부모-자신관계★임을 알 수 있습니다. User가 본인이 속한 Group을 가져온 코드이기 때문입니다. 하지만 여기에 데이터베이스가 추가되면 다음과 같이 변경됩니다.
				| User user = userDao.findUser();	        	              |
				| Group group = groupDao.findGroup(user.getGroupId());   |
User 따로, Group 따로 조회하게 됩니다. User와 Group이 어떤 관계인지 알 수 있을까요? 상속, 1:N 등 다양한 객체 모델링을 데이터베이스로는 구현할 수 없습니다. 그러다 보니 웹 애플리케이션 개발은 점점 ★데이터베이스 모델링★에만 집중하게 됩니다. JPA는 이런 문제점을 해결하기 위해 등장하게 됩니다.
서로 지향하는 바가 다른 2개 영역 (객체지향 프로그래밍 언어와 관계형 데이터베이스)을 ★중간에서 패러다임 일치★를 시켜주기 위한 기술입니다. 즉, 개발자는 ★객체지향적으로 프로그래밍을 하고★, JPA가 이를 관계형 데이터베이스에 맞게 SQL을 대신 생성해서 실행합니다. 개발자는 항상 객체지향족으로 코드를 표현할 수 있으니 더는 ★SQL에 종속적인 개발을 하지 않아도 됩니다.★
 객체 중심으로 개발을 하게 되니 생산성 향상은 물론 유지 보수하기가 정말 편합니다. 이런 점 때문에 규모가 크고 365일 24시간, 대규모 트래픽과 데이터를 가진 서비스에서 JPA는 점점 표준 기술로 자리 잡고 있습니다.

----------------------------------------------------------------------------------------------------------------------------------------------

Spring Data JPA
 JPA는 인터페이스로서 자바 표준명세서 입니다. 인터페이스인 JPA를 사용하기 위해서는 구현체가 필요합니다. 대표적으로 Hibernate, EclipseLink 등이 있습니다. 하지만 Spring에서 JPA를 사요할 때는 이 구현체들을 직접 다루진 않습니다. 구현체들을 좀 더 쉽게 사용하고자 추상화시킨 Spring Data JPA라는 모듈을 이용하는 JPA 기술을 다릅니다. 

●  JPA  ←  Hibername  ←  Spring Data JPA

 Hibernate를 쓰는 것과 Spring Data JPA를 쓰는 것 사이에는 큰 차이가 없습니다. 그럼에도 스프링 진영에서는 Spring Data JPA를 개발했고, 이를 권장하고 있습니다. 이렇게 한 단계 더 감싸놓은 Spring Data JPA가 등장한 이유는 크게 두가지가 있습니다.

● 구현체 교체의 용이성
● 저장소 교체의 용이성

먼저 '구현체 교체의 용이성' 이란 ◆Hibernate 외에 다른 구현체로 쉽게 교체하기 위함◆ 입니다. Hibernate가 언젠간 수명을 다해서 새로운 JPA 구현체가 대세로 떠오를 때, Spring Data JPA를 쓰는 중이라면 아주 쉽게 교체할 수 있습니다. Spring Data JPA 내부에서 구현체 매핑을 지원해주기 때문입니다. 실제로 자바의 Redis 클라이언트가 Jedis에서 Lettuce로 대세가 넘어갈 때 Spring Data Redis를 쓰신 분들은 아주 쉽게 교체를 했습니다.
 다음으로 '저장소 교체의 용이성' 이란 ◆관계형 데이터베이스 외에 다른 저장소로 쉽게 교체하기 위함◆ 입니다. 서비스 초기에는 관계형 데이터베이스로 모든 기능을 처리했지만, 점점 트래픽이 많아져 관계형 데이터베이스로는 도저히 감당이 안 될 때가올 수 있습니다. 이때 MongoDB로 교체가 필요하다면 개발자는 ◆Spring Data JPA에서 Spring Data MongoDB로 의존성◆만 교체하면 됩니다. 이는 Spring Data 의 하위 프로젝트들은 기본적인 ◆CRUD의 인터페이스가 같기◆ 때문입니다. 즉, Spring Data JPA, Spring Data Redis, Spring Data MongoDB등등 Spring Data의 하위 프로젝트들은 save(), findAll, findOne() 등을 인터페이스로 갖고 있습니다. 그러다 보니 저장소가 교체되어도 기본적인 기능은 변경할 것이 없습니다. 이런 장점들로 인해 Hibername를 직접 쓰기보다는 Spring 팀에서 계속해서 Spring Data 프로젝트를 권장하고 잇습니다.

----------------------------------------------------------------------------------------------------------------------------------------------

P.87 build.gradle 에 추가한 JPA 의존성
1. spring-boot-starter-data-jpa
- 스프링 부트용 Spring Data Jpa 추상화 라이브러리 입니다.
- 스프링 부트 버전에 맞춰 자동으로 JPA관련 라이브러리들의 버전을 관리해 줍니다.
2. h2
- 인메모리 관계형 데이터베이스입니다.
- 별도의 설치가 필요 없이 프로젝트 의존성만으로 관리할 수 있습니다.
- 메모리에서 실행되기 때문에 애플리케이션을 재시작할 때마다 초기화된다는 점을 이용하여 테스트 용도로 많이 사용됩니다.
- 이 책에서는 JPA의 테스트, 로컬 환경에서의 구동에서 사용할 예정입니다.

----------------------------------------------------------------------------------------------------------------------------------------------

p.90 Posts 클래스 ( DB 와 매칭될 클래스 ) 
@Entity
- 테이블과 링크될 클래스임을 나타냅니다.
- 기본값으로 클래스의 카멜케이스 이름은 언더스코어 네이밍(_)으로 테이블을 이름을 매칭합니다.
@Id
- 해당 테이블의 PK 필드를 나타냅니다.
@GeneratedValue
- PK의 생성 규칙을 나타냅니다.
- 스프링 부트 2.0 에서는 GenerationType,Identity 옵션을 추가해야만 auto_increment가 도비니다.
@Column
- 테이블의 칼럼을 나타내며 굳이 선언하지 않더라도 해당 클래스의 필드는 모두 칼럼이 됩니다.
- 사용하는 이뉴는, 기본값 외에 추가로 변경이 필요한 옵션이 있으면 사용합니다.
- 문자열의 경우 VARCHAR(255) 가 기본값인데, 사이즈를 500으로 늘리고 싶거나, 타입을 TEXT로 변경하고 싶거나 등의 경우에 사용합니다.

----------------------------------------------------------------------------------------------------------------------------------------------

p.94 DB와 매칭될 Entity 클래스 Posts 클래스 생성이 끝나면 Posts 클래스로 Database를 접근하게 해줄 JpaRepository를 생성
- 보통 ibatis 나 MyBatis 등에서 Dao 라고 불리는 DB Layer 접근자입니다. JPA에서는 Repository라고 부르며 인터페이스로 생성합니다.
단순히 인터페이스를 생성 후, JpaRepository< Entity 클래스, PK 타입 > 를 상속하면 기본적인 CRUD 메소드가 자동으로 생성됩니다.
@Repository를 추가할 필요도 없다. 여기서 주의할 점은 Entity 클래스와 기본 Entity Repository는 함께 위치해야 한다. 둘은 아주 밀접한 관계이고, Entity 클래스는 기본 Repository 없이는 제대로 역할을 할 수가 없다. 나중에 프로젝트 규모가 커져 도메인별로 프로젝트를 분리해야 한다면 이때 Entity 클래스와 기본 Repository는 함께 움직여야 하므로 도메인 패키지에서 함께 관리한다.


----------------------------------------------------------------------------------------------------------------------------------------------

p.97 PostsRepositoryTest 클래스 어노테이션
@After 
- Junit에서 단위 테스트가 끝날 때마다 수행되는 메소드를 지정
- 보통은 배포 전 전체 테스트를 수행할 때 테스트간 데이터 침범을 막기 위해 사용합니다.
- 여러 테스트가 동시에 수행되면 테스트용 데이터베이스인 H2에 데이터가 그대로 남아 있어 다음 테스트 실행 시 테스트가 실패할 수 있습니다.
@postsRepository.save
- 테이블에 posts에 insert/update 쿼리를 실행합니다.
- id 값이 있다면 update가 , 없다면 insert 쿼리가 실행됩니다.
@postsRepository.findAll
- 테이블에 posts에 있는 모든 데이터를 조회해오는 메소드 입니다.

----------------------------------------------------------------------------------------------------------------------------------------------

p.100 등록/ 수정 / 조회 API 만들기
API 를 만들기 위해 총 3개의 클래스가 필요합니다.
- Request 데이터를 받을 Dto
- API 요청을 받을 Controller
- 트랜잭션, 도메인 기능 간의 순서를 보장하는 Service
여기서 많은 분들이 오해하고 계신 것이, ◆Service에서 비즈니스 로직을 처리◆해야 한다는 것입니다. 하지만, 전혀 그렇지 않습니다.
Service는 ◆트랜잭션, 도메인 간 순서 보장◆의 역할만 합니다.
★Spring 웹 계층★
Web Layer
- 흔히 사용하는 컨트롤러와 JSP/Freemarker 등의 뷰 템플릿 영역입니다.
- 이외에도 필터, 인터셉터, 컨트롤러 어드바이스 등 외부 요청과 응답에 대한 전반적인 영역을 이야기합니다.

Service Layer
- @Service에 사용되는 서비스 영역입니다.
- 일반적으로 Controller와 Dao 중간 영역에서 사용됩니다.
- @Transactional이 사용되어야 하는 영역이기도 합니다.

Repository Layer
- Database와 같이 데이터 저장소에 접근하는 영역입니다.
- 기존에 개발하셨던 분들이라면 Dao(Data Access Object) 영역으로 이해하시면 쉬울것입니다.

Dtos
- Dto(Data Transfer Object)는 ◆계층 간에 데이터 교환을 위한 객체◆를 이야기하며 Dtos는 이들의 영역을 얘기합니다.
- 예를 들어 뷰 템플릿 엔진에서 사용될 객체나 Repository Layer 에서 결과로 넘겨준 객체 등이 이들을 이야기 합니다.

Domain Model
- 도메인이라 불리는 개발 대상을 모든 사람이 동일한 관점에서 이해할 수 있고 공유할 수 있도록 단순화시킨 것을 도메인 모델이라고 합니다.
- 이를테면 택시 앱이라고 하면 배차, 탑승, 요금 등이 모두 도메인이 될 수 있습니다.
- @Entity를 사용해신 분들은 @Entity가 사용된 영역 역시 도메인 모델이라고 이해해주시면 됩니다.
- 다만, 무조건 데이터베이스의 테이블과 관계가 있어야만 하는 것은 아닙니다.
- VO 처럼 값 객체들도 이 영역에 해당하기 때문입니다.

----------------------------------------------------------------------------------------------------------------------------------------------

* main application 에 @EnableJpaAudting 어노테이션을 작성하여 JPA Auditing 활성화 시켜줘야함
p.122 BaseTimeEntity 
보통 Entity에는 해당 데이터의 생성시간과 수정시간을 포함합니다. 언제 만들어졌는지 언제 수정되었는지 등은 차후 유지보수에 있어 굉장히 중요한 정보이기 때문입니다. 그렇다 보니 매번 DB에 insert 하기 전, update 하기 전에 날짜 데이터를 등록/수정하는 코드가 여기저기 들어가게 됩니다. 이런 단순하고 반복적인 코드가 모든 테이블과 서비스 메소드에 포함된다면 매우 귀찮고 코드가 지저분해집니다. 그래서 이 문제를 해결하고자 JPA Auditing를 사용합니다.

모든 Entity의 상위 클래스가 되어 Entity들의 createDate, modifiedDate를 자동으로 관리하는 역할

@MappedSuperclass
- JPA Entity 클래스들이 BaseTimeEntity 을 상속할 경우 필드들(createdate, modifieddate)도 칼럼으로 인식하도록 합니다.

@EntityListeners(AuditingEntityListener.class)
- BaseTimeEntity 클래스에 Auditing 기능을 포함시킵니다.

@CreateDate
- Entity가 생성되어 저장될 때 시간이 자동 저장됩니다.

@LastModifiedDate
- 조회한 Entity의 값을 변경할 때 시간이 자동 저장됩니다.

----------------------------------------------------------------------------------------------------------------------------------------------

